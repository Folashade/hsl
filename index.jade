doctype html
html
  head
    meta( charset='utf-8' )
    meta( name='viewport' content='initial-scale=1,user-scalable=no' )
    title HSL â€“ The RGB Youâ€™ve Been Waiting For
    link( href='slides.css' rel='stylesheet' type='text/css' )

  body( ng-app='hsl' ): deck

    slide: :marked( smartypants )
      HSL
      ===

      The RGB You've Been Waiting For
      -------------------------------

    notes: :marked( smartypants )
      This is a talk put together for the February 2016 [PeninsulaJS][1]
      meetup.

      The source for these slides is available at
      [github.com/visnup/hsl][2].

      [1]: http://peninsulajs.com/
      [2]: https://github.com/visnup/hsl

    slide.xs-center
      :marked( smartypants )
        The Problem
        ===========

      div( ng-init='lhs=RGB("ff","a5","00"); rhs=RGB("33","33","33")' )
        span.swatch( ng-style="{backgroundColor: lhs}" )
        input.c( ng-model='lhs.r' placeholder='R' ng-style='{borderBottomColor: lhs.rx}' )
        input.c( ng-model='lhs.g' placeholder='G' ng-style='{borderBottomColor: lhs.gx}' )
        input.c( ng-model='lhs.b' placeholder='B' ng-style='{borderBottomColor: lhs.bx}' )
        .op.text-muted +
        span.swatch( ng-style="{backgroundColor: rhs}" )
        input.c( ng-model='rhs.r' placeholder='R' ng-style='{borderBottomColor: rhs.rx}' )
        input.c( ng-model='rhs.g' placeholder='G' ng-style='{borderBottomColor: rhs.gx}' )
        input.c( ng-model='rhs.b' placeholder='B' ng-style='{borderBottomColor: rhs.bx}' )
        .op.text-muted =
        span( ng-show='false' ) {{sum = lhs.plus(rhs)}}
        span.swatch( ng-style="{backgroundColor: sum}" )
        input.c( ng-model='sum.r' placeholder='R' ng-style='{borderBottomColor: sum.rx}' readonly )
        input.c( ng-model='sum.g' placeholder='G' ng-style='{borderBottomColor: sum.gx}' readonly )
        input.c( ng-model='sum.b' placeholder='B' ng-style='{borderBottomColor: sum.bx}' readonly )

    notes: :marked( smartypants )
      RGB + RGB = ðŸ¤”
      --------------
      `#ffa500`â€Š--â€Šthat's orange. `#ffd833`â€Š--â€Šthat's not a lighter orange;
      it's yellow. _Of course_, you're thinking, _one does not simply add
      some GB to RGB to lighten a color_.

      Ok fine, then how do you lighten orange to get light orange? And wait,
      hold on: why canâ€™t I just add Rs, Gs, and Bs to lighten my colors? I
      mean, my computer knows `1 + 1 = 2`; it and I can agree on that. Yet
      `#ffa500` + `#004999` yields some kinda related color, but in a way
      that doesnâ€™t exactly make sense.

      In what world is that cool? I'll tell you in what world: in an
      adding-colors-of-light-together world. You know who lives in that
      world?  LEDs and CRTs, thatâ€™s who. And scientists who play with lasers,
      AKA crazy people.

    slide
      :marked( smartypants )
        RGB: adding lasers together
        ===========================

      div( ng-init='rgb=RGB("ff","a5","00")' )
        span.swatch( ng-style="{backgroundColor: rgb}" )
        input.c( ng-model='rgb.r' placeholder='R' ng-style='{borderBottomColor: rgb.rx}' )
        input.c( ng-model='rgb.g' placeholder='G' ng-style='{borderBottomColor: rgb.gx}' )
        input.c( ng-model='rgb.b' placeholder='B' ng-style='{borderBottomColor: rgb.bx}' )

    notes: :marked( smartypants )
      - Demo: RGB values next to each other and the color they make (zoom
        in and out)

      RGB is _not_ like some single origin, shade-grown, 1,300 meter
      elevation coffee beans you found in Alajuela, Costa Rica and roasted in
      small batches to give to your friends in Oakland.

      RGB _is_ like that guy in a North Face jacket and hoodie on the 38L
      Geary headed downtown, doing a line of cocaine off his iPhone. Yeah,
      RGB is not a "so-uncool-itâ€™s-cool-again" thing.

    slide
      .cool-not-cool( style='display: flex; text-align: center' )
        div
          h3 Probably still cool
          != '<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Three cordless screwdrivers and a microcontroller = perfect small batch coffee roasting. <a href="http://t.co/vrEWlzDP9A">http://t.co/vrEWlzDP9A</a> <a href="http://t.co/GbOVyJ1jFh">pic.twitter.com/GbOVyJ1jFh</a></p>&mdash; Make: (@make) <a href="https://twitter.com/make/status/643920371780087808">September 15, 2015</a></blockquote>'
        | &nbsp;
        div
          h3 Not cool
          != '<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Some guy doing lines of cocaine off his iphone on muni... <a href="http://t.co/8KgMSljp">pic.twitter.com/8KgMSljp</a></p>&mdash; Nolan Evans (@nolman) <a href="https://twitter.com/nolman/status/229042680498368513">July 28, 2012</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

    slide
      :marked( smartypants )
        RGB is a color space
        ====================

        [cool R, G, B = X, Y, Z thing]
    notes: :marked( smartypants )
      RGB is what we call a **color space**, which sounds more scary than it
      really is. I'd define a color space as "a system to specify a color and
      reason about sets of colors."

      It's actually really similar to the **Cartesian X, Y, Z** system to
      specify positions in... _space_. So, just like I can say the corner of
      the room is `{ 0, 0, 0 }` and to get to me, you go 20' along that wall
      and 10' along this other wall, and then another 5'8" upwards to get to
      my head, we can do the same thing with color. Instead of X, Y, and Z,
      we use R, G, and B.

      But what about the case where all I care about is answering "how far
      away you are from me and in what direction?" If we're constrainted to
      XYZ, I have to go back to that corner and figure out your position and
      then do some vector math to find the distance and angle. 

      And that's where **polar coordinates** come from (if you remember that
      mind-blowing 6th grade geometry class). It's just a different way of
      specifying all the same positions that you could with X,Y, and Z, but
      re-frames it in a totally different system. And when we shift our
      perspective that way, some operations become a _lot simpler_ and _more
      intuitive_.

    slide: :marked( smartypants )
      Let's make our own color space
      ==============================

      - Communicate to another person what color we want
      - Perform some common tasks on those colors
      - Intuitive

    notes: :marked( smartypants )
      How would you describe _to the person next to you_ the color of the <span
      style="background: skyblue">sky</span>? How would you compare that to the
      color of the <span style="background: aquamarine">ocean</span>? How would
      you compare those colors to each other?

      Letâ€™s pretend we were tasked with representing all the colors in an
      _intuitive_ way. How would we start?

      How about, let's just take the rainbow (**ROY G. BIV!**) and stick it in
      a kinda big array:
      
    slide
      :marked( smartypants )
        Color / Swatch / Hue
        --------------------

      .hue( ng-init='buckets.h = 9' )
        p Letâ€™s divide the rainbow up into 
          input.c( ng-model='buckets.h' type='number' step=3 )
          |  colors:

        .hues.scale
          span.swatch(
            ng-repeat='h in _.range(0, buckets.h)'
            ng-style="{backgroundColor: HSL(h*360/buckets.h, 100, 50)}"
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2, 3]' ) {{c*buckets.h/3 | number}}

    notes: :marked( smartypants )
      That's kinda intuitive-looking already. We've got lots of the colors we
      care about in an array indexed from 0 to {{buckets.h}}. So, if I want red
      I just grab the color at 0 and if I want magenta, I grab the one at
      {{buckets.h}}. {{buckets.h/3}}ish is green and {{buckets.h*2/3}}ish is
      blue; itâ€™s just a mapping and as we move up and down the scale we get a
      predictable color from the rainbow.

      We want to have more crayons in our box though, so increase that number
      to something high, like 99. Now we're getting a proper rainbow.

    slide
      :marked( smartypants )
        Brightness / Colorfulness / Saturation
        --------------------------------------

      .saturation( ng-init='hsl = HSL(300, 100, 50); buckets.s = 10' )
        p Picking from our rainbow,
        .hues.scale
          span.swatch(
            ng-repeat='h in _.range(0, 360)'
            ng-style="{backgroundColor: HSL(h, 100, 50)}"
            ng-mouseenter='hsl.h = h'
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2, 3]' ) {{c*360/3 | number}}

        p a hue of 
          span.swatch( ng-style='{backgroundColor: HSL(hsl.h, 100, 50)}' )
          input.c( ng-model='hsl.h' placeholder='H' ng-style='{borderBottomColor: HSL(hsl.h, 100, 50)}' )
          | , letâ€™s bucket its <b>colorfulness</b> on a scale from 0 to 
          input.c( ng-model='buckets.s' type='number' step=10 )
          | :

        .saturations.scale
          span.swatch(
            ng-repeat='s in _.range(0, buckets.s)'
            ng-style="{backgroundColor: HSL(hsl.h, s*100/buckets.s, hsl.l)}"
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2]' ) {{c*buckets.s/2 | number}}

    slide
      :marked( smartypants )
        Lightness
        ---------

      .lightness
        p Picking from our rainbow,
        .hues.scale
          span.swatch(
            ng-repeat='h in _.range(0, 360)'
            ng-style="{backgroundColor: HSL(h, 100, 50)}"
            ng-mouseenter='hsl.h = h'
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2, 3]' ) {{c*360/3 | number}}

        p a hue of 
          span.swatch( ng-style='{backgroundColor: HSL(hsl.h, 100, 50)}' )
          input.c( ng-model='hsl.h' placeholder='H' ng-style='{borderBottomColor: HSL(hsl.h, 100, 50)}' )
          | , and from our saturation scale,

        .saturations.scale
          span.swatch(
            ng-repeat='s in _.range(0, 100)'
            ng-style="{backgroundColor: HSL(hsl.h, s, hsl.l)}"
            ng-mouseenter='hsl.s = s'
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2]' ) {{c*100/2 | number}}

        p a saturation of 
          span.swatch( ng-style='{backgroundColor: HSL(hsl.h, hsl.s, 50)}' )
          input.c( ng-model='hsl.s' placeholder='S' ng-style='{borderBottomColor: HSL(hsl.h, hsl.s, 50)}' )

        .lightness.scale
          span.swatch(
            ng-repeat='l in _.range(0, 100)'
            ng-style="{backgroundColor: HSL(hsl.h, hsl.s, l)}"
          )
        .indexes.scale
          span( ng-repeat='c in [0, 1, 2]' ) {{c*100/2 | number}}
      
    slide
      :marked( smartypants )
        Putting it all together
        =======================
    notes
      :marked( smartypants )
        - Gamut
        - Transform from RGB
      
    slide
      :marked( smartypants )
        Let's do some stuff with HSL
        ============================
      
    slide
      :marked( smartypants )
        Lighten a color
        ---------------
    notes
      :marked( smartypants )
        - This is the original problem at the beginning
    
    slide
      :marked( smartypants )
        Grayscale a photo
        -----------------

    slide
      :marked( smartypants )
        Make a color palette
        --------------------
      
    slide
      :marked( smartypants )
        HSL is everywhere already
        =========================
    notes
      :marked( smartypants )
        - Chrome dev tools
        - Color pickers
          - OS X
          - Sketch
          - Google slides
        - colorhexa.com
      
    slide
      :marked( smartypants )
        LAB
        ===

        The HSL You've Been Waiting For
        -------------------------------
    notes
      :marked( smartypants )
        So, I know I just told you HSL was like the new Kanye album, but there
        are some problems with HSL.

        Luckily, there are some people who _really care_ about this type of
        stuff. They call themselves the **International Commission on
        Illumination** or if you like French, **Commission internationale de
        l'Ã©clairage**, or if you think that's a mouthful, **CIE** for short.

        They've published an _even better_ colour space definition that takes
        into account how the human eye perceives colour along with what
        lighting conditions you're in and how long you've been fermenting that
        kombucha you're drinking. It's called [CIELAB][1] and it's _crazy_.

        - Lightness
        - Perceptual uniformity

        [1]: https://en.wikipedia.org/wiki/Lab_color_space
      
    script( src='https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.5.0/angular.min.js' )
    script( src='https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.5.0/lodash.min.js' )
    script.
      'use strict'

      class RGB {
        constructor(r, g, b) {
          this.r = r
          this.g = g
          this.b = b
        }

        set r(r) { this._r = parseInt(r || 0, 16) }
        set g(g) { this._g = parseInt(g || 0, 16) }
        set b(b) { this._b = parseInt(b || 0, 16) }

        get r()  { return this._r.toString(16) }
        get g()  { return this._g.toString(16) }
        get b()  { return this._b.toString(16) }

        get rx() { return new RGB(this._r, 0, 0) }
        get gx() { return new RGB(0, this._g, 0) }
        get bx() { return new RGB(0, 0, this._b) }

        plus(other) {
          var r = _.clamp(this._r + other._r, 0, 255),
              g = _.clamp(this._g + other._g, 0, 255),
              b = _.clamp(this._b + other._b, 0, 255)
          return new RGB(r.toString(16), g.toString(16), b.toString(16))
        }

        toString() {
          return `rgb(${this._r},${this._g},${this._b})`
        }
      }

      class HSL {
        constructor(h, s, l) {
          this.h = h
          this.s = s
          this.l = l
        }

        toString() {
          return `hsl(${this.h},${this.s}%,${this.l}%)`
        }
      }

      angular
        .module('hsl', [])
        .component('deck', {
          controller($document) {
            this.slides = []
            
            this.add = function(slide) {
              this.slides.push(slide)
              return this.slides.length - 1
            }

            $document.on('keydown', function(e) {
              if (e.target.nodeName !== 'BODY') return
              var index = +location.hash.slice(1) || 0
              switch (e.keyIdentifier) {
                case 'Right':
                  index++
                  break
                case 'Left':
                  index--
                  break
              }
              location.hash = _.clamp(index, 0, this.slides.length)
            }.bind(this))
          }
        })
        .component('slide', {
          require: { deck: '^deck' },
          controller($element) {
            this.$onInit = function() {
              $element.attr('id', this.deck.add(this))
            }
          }
        })
        .run(function($rootScope) {
          $rootScope._ = _
          $rootScope.RGB = function(r, g, b) { return new RGB(r, g, b) }
          $rootScope.HSL = function(h, s, l) { return new HSL(h, s, l) }
        })
